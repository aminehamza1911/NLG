"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RandomManager = void 0;
const random_js_1 = require("random-js");
class RandomManager {
    //spy: Spy;
    constructor(randomSeed) {
        this.incrRandomer = 10;
        this.rndNextPos = 0;
        this.rndTable = [];
        this.rndEngine = new random_js_1.Random(random_js_1.MersenneTwister19937.seed(randomSeed));
    }
    getRndNextPos() {
        return this.rndNextPos;
    }
    setRndNextPos(rndNextPos) {
        this.rndNextPos = rndNextPos;
    }
    /*
    public setSpy(spy: Spy): void {
      this.spy = spy;
    }
    */
    incrRnd(incr) {
        for (let i = 0; i < incr; i++) {
            this.getNextRnd(); // we don't care about the result
        }
    }
    getNextRnd() {
        if (this.rndNextPos >= this.rndTable.length) {
            // console.log("ADDING NEW RANDOM IN THE TABLE");
            //const time = process.hrtime();
            for (let i = 0; i < this.incrRandomer; i++) {
                /*
                  comporte des biais : https://www.npmjs.com/package/random-js ; trouver mieux ?
                */
                this.rndTable.push(this.rndEngine.real(0, 1, false));
            }
            //const diff = process.hrtime(time);
        }
        return this.rndTable[this.rndNextPos++];
    }
    getItemWeight(params, item) {
        return (params[item] && params[item].weight) || 1;
    }
    getSumOfWeights(max, params) {
        let sumOfWeights = 0;
        for (let i = 1; i <= max; i++) {
            sumOfWeights += this.getItemWeight(params, i);
        }
        return sumOfWeights;
    }
    /*
      https://stackoverflow.com/questions/6443176/how-can-i-generate-a-random-number-within-a-range-but-exclude-some
      https://medium.com/@peterkellyonline/weighted-random-selection-3ff222917eb6
    */
    getTargetIndex(origIndex, excludes) {
        let targetIndex = 0;
        for (let i = 1; i <= origIndex; i++) {
            targetIndex++;
            while (excludes.indexOf(targetIndex) > -1) {
                targetIndex++;
            }
        }
        return targetIndex;
    }
    getWeightedRandom(max, weights) {
        const sumOfWeights = this.getSumOfWeights(max, weights);
        let randomWeight = Math.floor(this.getNextRnd() * sumOfWeights) + 1;
        // console.log(`sumOfWeights: ${sumOfWeights}, randomWeight: ${randomWeight}`);
        for (let i = 1; i <= max; i++) {
            randomWeight = randomWeight - this.getItemWeight(weights, i);
            if (randomWeight <= 0) {
                // console.log(`=> found: ${i}`);
                return i;
            }
        }
    }
    randomNotIn(max, weights, excludes) {
        // console.log(`ASKS: [1,${max}], excludes: ${excludes}`);
        if (excludes.length === max) {
            // it won't be possible to find a new one
            return null;
        }
        //il faut translater les index des poids
        const translatedWeights = {};
        let newIndex = 0;
        for (let i = 1; i <= max; i++) {
            if (excludes.indexOf(i) === -1) {
                newIndex++;
                translatedWeights[newIndex] = { weight: this.getItemWeight(weights, i) };
            }
        }
        // console.log(`original weights: ${JSON.stringify(weights)}, excluded: ${excludes}, translated weights: ${JSON.stringify(translatedWeights)}`);
        const weightedRandom = this.getWeightedRandom(max - excludes.length, translatedWeights);
        //// console.log(`must return non excluded #${found}`);
        // inverse mapping
        const targetIndex = this.getTargetIndex(weightedRandom, excludes);
        // console.log(targetIndex);
        return targetIndex;
    }
}
exports.RandomManager = RandomManager;
//# sourceMappingURL=RandomManager.js.map