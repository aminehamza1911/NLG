"use strict";
/**
 * @license
 * Copyright 2019 Ludan StoecklÃ©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GenderNumberManager = void 0;
class GenderNumberManager {
    constructor(languageImpl) {
        this.languageImpl = languageImpl;
        this.refNumberMap = new Map();
        this.refGenderMap = new Map();
    }
    getRefGenderMap() {
        return this.refGenderMap;
    }
    setRefGenderMap(refGenderMap) {
        this.refGenderMap = refGenderMap;
    }
    getRefNumberMap() {
        return this.refNumberMap;
    }
    setRefNumberMap(refNumberMap) {
        this.refNumberMap = refNumberMap;
    }
    isEmptyObj(obj) {
        if (!obj)
            return true;
        return Object.keys(obj).length === 0 && obj.constructor === Object;
    }
    setRefGenderNumber(obj, gender, number) {
        if (this.isEmptyObj(obj)) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = 'setRefGenderNumber obj should not be empty';
            throw err;
        }
        // dumpRefMap();
        if (gender) {
            this.setRefGender(obj, gender, null);
        }
        if (number) {
            this.setRefNumber(obj, number);
        }
        // console.log(`just called setRefGenderNumber on ${JSON.stringify(obj)} ${gender} ${number}`);
        // dumpRefMap();
    }
    setRefGender(obj, genderOrWord, params) {
        //console.log(`setRefGenderNumber ${obj} ${genderOrWord}`);
        if (this.isEmptyObj(obj)) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = 'setRefGender obj should not be empty';
            throw err;
        }
        // dumpRefMap();
        // console.log('setRefGender: ' + JSON.stringify(obj).substring(0, 20) + ' => ' + genderOrWord);
        let explicitGender;
        if (params && params.gender) {
            explicitGender = params.gender;
        }
        if (['M', 'F', 'N'].indexOf(genderOrWord) > -1) {
            explicitGender = genderOrWord;
        }
        if (explicitGender) {
            if (explicitGender != 'M' && explicitGender != 'F' && !this.languageImpl.hasNeutral) {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `invalid neutral gender in ${this.languageImpl.iso2}`;
                throw err;
            }
            this.refGenderMap.set(obj, explicitGender);
            return;
        }
        else if (genderOrWord) {
            // is a word
            const gender = this.getWordGender(genderOrWord);
            this.refGenderMap.set(obj, gender);
            return;
        }
        else {
            // called with null for instance
            // do nothing
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `setRefGender called on ${JSON.stringify(obj)} with invalid genderOrWord ${genderOrWord}`;
            throw err;
        }
        // dumpRefMap();
    }
    getRefGender(obj, params) {
        // console.log('getRefGender called on: ' + JSON.stringify(obj));
        const inMainMap = this.refGenderMap.get(obj);
        if (inMainMap) {
            return inMainMap;
        }
        else if (typeof obj === 'string') {
            if (params) {
                if (params.gender) {
                    return params.gender;
                }
                if (this.languageImpl.userGenderOwnedForGender && params.genderOwned) {
                    return params.genderOwned;
                }
            }
            if (this.languageImpl.hasGender) {
                // we try to get the gender and throw an exception if not found
                return this.getWordGender(obj);
            }
            else {
                // we don't care
                return null;
            }
        }
        return null;
    }
    getAnonymous(gender, number) {
        // console.log("getAnonymous");
        const obj = { isAnonymous: true };
        this.setRefGenderNumber(obj, gender, number);
        return obj;
    }
    getAnonMS() {
        return this.getAnonymous('M', 'S');
    }
    getAnonMP() {
        return this.getAnonymous('M', 'P');
    }
    getAnonFS() {
        return this.getAnonymous('F', 'S');
    }
    getAnonFP() {
        return this.getAnonymous('F', 'P');
    }
    getNumberFromObj(obj) {
        if (typeof obj === 'string') {
            if (obj === 'S' || obj === 'P') {
                return obj;
            }
            else {
                return null;
            }
        }
        else {
            return this.refNumberMap.get(obj);
        }
    }
    getRefNumber(obj, params) {
        // numberOwned > number > obj
        if (params) {
            if (params.numberOwned) {
                return this.getNumberFromObj(params.numberOwned);
            }
            else if (params.number) {
                return this.getNumberFromObj(params.number);
            }
        }
        if (obj != null) {
            return this.getNumberFromObj(obj);
        }
        return null;
    }
    setRefNumber(obj, number) {
        if (this.isEmptyObj(obj)) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = 'setRefNumber obj should not be empty';
            throw err;
        }
        if (number != 'S' && number != 'P') {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `number must be S or P! - here is ${number}`;
            throw err;
        }
        // dumpRefMap();
        this.refNumberMap.set(obj, number);
        // dumpRefMap();
    }
    getWordGender(word) {
        return this.languageImpl.getWordGender(word);
    }
}
exports.GenderNumberManager = GenderNumberManager;
//# sourceMappingURL=GenderNumberManager.js.map